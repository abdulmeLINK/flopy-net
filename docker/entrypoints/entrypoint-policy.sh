#!/bin/bash
# Entrypoint script for Policy Engine container

# Configure error handling
set -e
set -o pipefail

# Setup logging
LOGS_DIR="/app/logs"
mkdir -p "$LOGS_DIR"
LOG_FILE="$LOGS_DIR/policy-engine.log"
touch $LOG_FILE
chmod 777 "$LOG_FILE"
chmod -R 777 /app/logs

# Log function
log() {
  local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
  local level=${1:-INFO}
  local message=$2
  if [ "$#" -eq 1 ]; then
    message=$level
    level="INFO"
  fi
  echo "[$timestamp] [POLICY-ENGINE] [$level] $message" | tee -a "$LOG_FILE"
}

# Function to check if an IP is valid (not empty, not loopback, not link-local)
is_valid_ip() {
  local ip="$1"
  # Check if IP is empty
  if [ -z "$ip" ]; then
    return 1
  fi
  
  # Check if IP is loopback (127.x.x.x)
  if [[ "$ip" =~ ^127\. ]]; then
    return 1
  fi
  
  # Check if IP is link-local (169.254.x.x)
  if [[ "$ip" =~ ^169\.254\. ]]; then
    return 1
  fi
  
  return 0
}

# Validation function for IP addresses
validate_ip() {
  local ip=$1
  if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    IFS='.' read -r -a segments <<< "$ip"
    for segment in "${segments[@]}"; do
      if (( segment > 255 )); then
        return 1
      fi
    done
    return 0
  else
    return 1
  fi
}

# Function to update hosts file
update_hosts_entry() {
  local ip=$1
  local hostname=$2
  
  # Skip if IP is invalid
  if ! validate_ip "$ip"; then
    log "WARNING" "Invalid IP for hosts entry: $ip, skipping"
    return 1
  fi
  
  # Create a temp file for hosts updates to avoid "device busy" errors
  TEMP_HOSTS=$(mktemp)
  
  # Check if entry already exists with exact match
  if grep -q "^$ip[[:space:]].*$hostname\($\|[[:space:]]\)" /etc/hosts; then
    # Entry exists with this IP and hostname, do nothing
    log "INFO" "Hosts entry already exists for $hostname -> $ip"
    rm -f "$TEMP_HOSTS"
    return 0
  fi
  
  # Remove any existing entries for this hostname
  grep -v "[[:space:]]$hostname\($\|[[:space:]]\)" /etc/hosts > "$TEMP_HOSTS"
  
  # Add the new entry
  echo "$ip $hostname" >> "$TEMP_HOSTS"
  
  # Replace the hosts file atomically
  cat "$TEMP_HOSTS" > /etc/hosts
  
  # Clean up
  rm -f "$TEMP_HOSTS"
  
  log "Added/updated hosts entry: $ip -> $hostname"
  return 0
}

# Function to verify policy engine API is running
verify_policy_engine_api() {
  local port="$1"
  local max_attempts=10
  local attempt=1
  local wait_time=2
  
  log "INFO" "Verifying policy engine API is running on port $port..."
  
  while [ $attempt -le $max_attempts ]; do
    # Check if process is listening on the port
    if netstat -tuln | grep -q ":$port "; then
      log "INFO" "Port $port is open, checking if API responds..."
      
      # Try to access the health endpoint
      if curl -s http://localhost:$port/health > /dev/null 2>&1; then
        log "SUCCESS" "Policy engine API is responding on port $port"
        return 0
      fi
    fi
    
    log "INFO" "Policy engine API not yet responding on port $port (attempt $attempt/$max_attempts)"
    sleep $wait_time
    attempt=$((attempt + 1))
  done
  
  log "ERROR" "Policy engine API not responding on port $port after $max_attempts attempts"
  return 1
}

# Function to create a default policy file if none exists
ensure_default_policies() {
  local policy_dir="$1"
  # Determine the default policy filename (env var or default)
  local default_policy_filename=${DEFAULT_POLICY_FILENAME:-"default_policies.json"}
  local default_policy_file="$policy_dir/$default_policy_filename"
  
  if [ ! -d "$policy_dir" ]; then
    log "INFO" "Creating policy directory: $policy_dir"
    mkdir -p "$policy_dir"
  fi
  
  if [ ! -f "$default_policy_file" ] || [ ! -s "$default_policy_file" ]; then
    log "INFO" "Default policy file '$default_policy_filename' not found or empty in $policy_dir. Creating comprehensive default file at $default_policy_file"
    
    # Create a more comprehensive default policy file
    cat > "$default_policy_file" << EOF
{
  "description": "Default policies generated by entrypoint script if $default_policy_filename is missing.",
  "policies": [
    {
      "id": "default-icmp-allow",
      "name": "Default: Allow All ICMP",
      "type": "network_security",
      "enabled": true,
      "priority": 10,
      "rules": [
        {
          "id": "default-icmp-rule",
          "action": "allow",
          "match": {
            "protocol": "icmp"
          },
          "description": "Allows basic ICMP connectivity (ping, etc.)"
        }
      ]
    },
    {
      "id": "default-tcp-fl-basic",
      "name": "Default: Allow Basic FL Client/Server TCP",
      "type": "network_security",
      "enabled": true,
      "priority": 50,
      "rules": [
        {
          "id": "default-client-to-server",
          "action": "allow",
          "match": {
            "protocol": "tcp",
            "src_type": "fl-client", 
            "dst_type": "fl-server",
            "destination_port": 8080
          },
          "description": "Allows FL Clients to connect to the FL Server"
        },
        {
          "id": "default-server-to-client",
          "action": "allow",
          "match": {
            "protocol": "tcp",
            "src_type": "fl-server",
            "dst_type": "fl-client"
          },
          "description": "Allows FL Server to communicate back to FL Clients"
        }
      ]
    },
    {
      "id": "default-collector-access",
      "name": "Default: Allow Collector Access",
      "type": "network_security",
      "enabled": true,
      "priority": 40,
      "rules": [
        {
          "id": "default-all-to-collector",
          "action": "allow",
          "match": {
            "protocol": "tcp",
            "dst_type": "collector",
            "destination_port": 9090 
          },
          "description": "Allows components to send data to Collector (port 9090)"
        },
        {
          "id": "default-collector-to-server",
          "action": "allow",
          "match": {
            "protocol": "tcp",
            "src_type": "collector", 
            "dst_type": "fl-server",
            "destination_port": 8080 
          },
          "description": "Allows Collector to connect to FL Server"
        },
        {
          "id": "default-collector-to-sdn",
          "action": "allow",
          "match": {
            "protocol": "tcp",
            "src_type": "collector", 
            "dst_type": "sdn-controller", 
            "destination_port": 8181 
          },
          "description": "Allows Collector to connect to SDN Controller REST API"
        }
      ]
    },
    {
      "id": "default-policy-engine-access",
      "name": "Default: Allow Access to Policy Engine",
      "type": "network_security",
      "enabled": true,
      "priority": 45,
      "rules": [
         {
          "id": "default-all-to-policy-engine",
          "action": "allow",
          "match": {
            "protocol": "tcp",
            "dst_type": "policy-engine",
            "destination_port": 5000
          },
          "description": "Allows components to connect to Policy Engine (port 5000)"
        }
      ]
    }
  ]
}
EOF
    log "SUCCESS" "Created default policy file: $default_policy_file"
  else
    log "INFO" "Default policy file '$default_policy_filename' already exists at $default_policy_file"
  fi
}

# Handle the legacy policy path for compatibility
# Create symlink if needed, but don't fail if it already exists
setup_policy_directories() {
  # Define the primary policy directory and any legacy paths that need to point to it
  local primary_policy_dir="/app/config/policies"
  local legacy_policy_dir="/app/config/policy"
  
  # Ensure the primary policy directory exists
  if [ ! -d "$primary_policy_dir" ]; then
    log "INFO" "Creating primary policy directory: $primary_policy_dir"
    mkdir -p "$primary_policy_dir"
  fi
  
  # Set up compatibility symlink if it doesn't exist yet and is needed
  if [ ! -e "$legacy_policy_dir" ] && [ "$legacy_policy_dir" != "$primary_policy_dir" ]; then
    log "INFO" "Creating compatibility symlink: $legacy_policy_dir -> $primary_policy_dir"
    ln -sf "$primary_policy_dir" "$legacy_policy_dir"
  fi
  
  # Set correct permissions
  chmod -R 755 "$primary_policy_dir"
  
  # Ensure policy file exists in the right location
  if [ -n "$POLICY_FILE" ]; then
    local policy_file_dir=$(dirname "$POLICY_FILE")
    if [ ! -d "$policy_file_dir" ]; then
      log "INFO" "Creating policy file directory: $policy_file_dir"
      mkdir -p "$policy_file_dir"
    fi
  fi
  
  # Update the environment variable to point to the correct location
  # If it was previously set to use legacy_policy_dir, update it
  if [ "$POLICY_FILE" = "${legacy_policy_dir}/policies.json" ]; then
    export POLICY_FILE="${primary_policy_dir}/policies.json"
    log "INFO" "Updated POLICY_FILE environment variable to: $POLICY_FILE"
  fi
}

log "Starting Policy Engine entrypoint script"

# Call the directory setup function early in the script
setup_policy_directories

# Get container information
HOSTNAME=${HOSTNAME:-$(hostname)}
CONTAINER_ID=$(cat /etc/hostname)

# Set default values for environment variables
: "${SERVICE_TYPE:=policy}"
: "${SERVICE_ID:=policy-engine}"
: "${HOST:=0.0.0.0}"
: "${POLICY_PORT:=5000}"
: "${METRICS_PORT:=9091}"
: "${LOG_LEVEL:=INFO}"
: "${NETWORK_MODE:=docker}"
: "${GNS3_NETWORK:=false}"
: "${USE_STATIC_IP:=false}"
: "${WAIT_FOR_SERVICES_TIMEOUT:=30}"

# Calculate policy engine offset based on ID if present
POLICY_OFFSET=0
if [[ "$SERVICE_ID" =~ [0-9]+$ ]]; then
  POLICY_OFFSET=$(echo "$SERVICE_ID" | grep -oE '[0-9]+$')
fi

log "Service type: $SERVICE_TYPE"
log "Service ID: $SERVICE_ID"
log "Logging level: $LOG_LEVEL"
log "Network mode: $NETWORK_MODE"
log "GNS3 network: $GNS3_NETWORK"
log "Static IP mode: $USE_STATIC_IP"
log "Policy host: $HOST"
log "Policy port: $POLICY_PORT"
log "Metrics port: $METRICS_PORT"

# Get the policy engine IP
POLICY_IP="$NODE_IP_POLICY_ENGINE"
if [ -z "$POLICY_IP" ]; then
  log "ERROR" "No IP found for NODE_IP_POLICY_ENGINE environment variable"
  exit 1
fi

log "INFO" "Policy Engine IP: $POLICY_IP"

# GNS3 specific or Static IP mode
# Trigger static IP assignment if USE_STATIC_IP is true
if [ "$USE_STATIC_IP" = "true" ]; then
  log "INFO" "Static IP mode enabled, performing special network initialization"
  
  # Determine the interface to use (default to eth0)
  TARGET_IFACE="eth0"
  if [ -n "$NETWORK_INTERFACE" ]; then
      TARGET_IFACE="$NETWORK_INTERFACE"
      log "INFO" "Using specified network interface: $TARGET_IFACE"
  else
      # Verify eth0 exists, otherwise try finding another eth interface
      if ! ip link show eth0 > /dev/null 2>&1; then
          log "WARNING" "Default interface eth0 not found, searching for another ethX..."
          FOUND_IFACE=$(ip link show | grep -oP '^\d+:\s+\Keth[0-9]+' | head -n 1)
          if [ -n "$FOUND_IFACE" ]; then
              TARGET_IFACE="$FOUND_IFACE"
              log "INFO" "Found alternative interface: $TARGET_IFACE"
          else
              log "ERROR" "Cannot find a suitable ethX interface. Exiting."
              exit 1
          fi
      else
          log "INFO" "Using default network interface: $TARGET_IFACE"
      fi
  fi
  
  # Ensure interface is up
  log "INFO" "Bringing up interface $TARGET_IFACE..."
  ip link set "$TARGET_IFACE" up || {
      log "ERROR" "Failed to bring up interface $TARGET_IFACE. Exiting."
      exit 1
  }
  
  # Flush existing IP addresses from the interface
  log "INFO" "Flushing existing IP addresses from $TARGET_IFACE..."
  ip addr flush dev "$TARGET_IFACE" scope global || log "WARNING" "Failed to flush interface $TARGET_IFACE (may have had no IP)"
  sleep 1 # Give a moment for the flush to settle
  
  # Simple static IP assignment
  log "INFO" "Assigning static IP $POLICY_IP/24 to $TARGET_IFACE"
  ip addr add "$POLICY_IP/24" dev "$TARGET_IFACE" || {
    log "ERROR" "Failed to assign IP $POLICY_IP to $TARGET_IFACE. Check network configuration and permissions. Exiting."
    exit 1
  }
    
  # Verify IP was actually assigned
  sleep 1
  ASSIGNED_IP=$(ip -4 addr show dev "$TARGET_IFACE" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}')
  if [ "$ASSIGNED_IP" == "$POLICY_IP" ]; then
    log "SUCCESS" "IP $ASSIGNED_IP successfully assigned to $TARGET_IFACE"
    CLEAN_IP="$ASSIGNED_IP"
    
    # Set up routing if we have a valid IP
    IFS='.' read -r -a IP_PARTS <<< "$CLEAN_IP"
    SUBNET="${IP_PARTS[0]}.${IP_PARTS[1]}.${IP_PARTS[2]}"
    log "INFO" "Subnet: $SUBNET.0/24"
    
    # Set up routes properly
    if ! ip route | grep -q "default"; then
      log "INFO" "Setting up default route via $SUBNET.1"
      ip route add default via $SUBNET.1 dev "$TARGET_IFACE" || log "WARNING" "Failed to add default route"
    fi
      
    # Try to ping gateway to verify connectivity
    if ping -c 1 -W 2 $SUBNET.1 >/dev/null 2>&1; then
      log "SUCCESS" "Network gateway at $SUBNET.1 is reachable"
    else 
      log "WARNING" "Cannot ping gateway at $SUBNET.1"
    fi
  else
    log "ERROR" "Failed to assign or verify static IP. Expected $POLICY_IP but found $ASSIGNED_IP on $TARGET_IFACE."
  fi
fi

# Add hosts entries for all NODE_IP_ variables
log "Adding hosts entries from NODE_IP_ variables"
for var in $(env | grep "^NODE_IP_" | sort); do
  varname=$(echo "$var" | cut -d= -f1)
  ip_value=$(echo "$var" | cut -d= -f2)
  
  # Skip if invalid IP
  if ! validate_ip "$ip_value"; then
    log "WARNING" "Invalid IP in $varname: $ip_value, skipping"
    continue
  fi
  
  # Extract hostname from variable name
  hostname=$(echo "${varname#NODE_IP_}" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
  
  log "Adding hosts entry: $hostname -> $ip_value"
  update_hosts_entry "$ip_value" "$hostname"
done

# Update own IP in hosts file
update_hosts_entry "127.0.0.1" "localhost"
if [ -n "$CLEAN_IP" ]; then
  update_hosts_entry "$CLEAN_IP" "$HOSTNAME"
  update_hosts_entry "$CLEAN_IP" "policy-engine"
  update_hosts_entry "$CLEAN_IP" "policy"
elif [ -n "$POLICY_IP" ]; then
  update_hosts_entry "$POLICY_IP" "$HOSTNAME"
  update_hosts_entry "$POLICY_IP" "policy-engine"
  update_hosts_entry "$POLICY_IP" "policy"
fi

log "Policy Engine environment setup complete"

# Create necessary directories with proper permissions
log "Creating necessary directories"
mkdir -p /app/logs
mkdir -p /app/config/policy_engine
mkdir -p /app/config/policies
chmod -R 777 /app/logs
chmod -R 777 /app/config

# Set variables for configuration
CONFIG_DIR=${CONFIG_DIR:-/app/config}
GENERATED_CONFIG_PATH=${POLICY_CONFIG:-${CONFIG_DIR}/policy_engine/policy_config.json}
POLICY_DIR=${POLICY_DIR:-${CONFIG_DIR}/policies}
FUNCTIONS_DIR=${POLICY_FUNCTIONS_DIR:-${CONFIG_DIR}/policy_functions}

# Ensure policy directory exists
mkdir -p "$POLICY_DIR"

# Create symbolic links for compatibility if needed
if [ "$POLICY_DIR" = "${CONFIG_DIR}/policies" ] && [ ! -L "${CONFIG_DIR}/policy" ]; then
  log "INFO" "Creating symbolic link from policy to policies directory"
  ln -sf "${CONFIG_DIR}/policies" "${CONFIG_DIR}/policy" 2>/dev/null || true
elif [ "$POLICY_DIR" = "${CONFIG_DIR}/policy" ] && [ ! -L "${CONFIG_DIR}/policies" ]; then
  log "INFO" "Creating symbolic link from policies to policy directory"
  ln -sf "${CONFIG_DIR}/policy" "${CONFIG_DIR}/policies" 2>/dev/null || true
fi

log "INFO" "Using policy directory: $POLICY_DIR"

# Check if default_policies.json exists in the policy directory
if [ ! -f "$POLICY_DIR/default_policies.json" ]; then
  # If it doesn't exist in the policy directory, check if it exists in another location
  if [ -f "${CONFIG_DIR}/policies/default_policies.json" ]; then
    log "INFO" "Copying default_policies.json from ${CONFIG_DIR}/policies/ to $POLICY_DIR/"
    cp "${CONFIG_DIR}/policies/default_policies.json" "$POLICY_DIR/"
  elif [ -f "${CONFIG_DIR}/policy/default_policies.json" ]; then
    log "INFO" "Copying default_policies.json from ${CONFIG_DIR}/policy/ to $POLICY_DIR/"
    cp "${CONFIG_DIR}/policy/default_policies.json" "$POLICY_DIR/"
  else
    log "WARNING" "default_policies.json not found in any standard location, default policies may not be available"
  fi
fi

# Check if policies.json exists in the policy directory
if [ ! -f "$POLICY_DIR/policies.json" ]; then
  # If it doesn't exist in the policy directory, check if it exists in another location
  if [ -f "${CONFIG_DIR}/policies/policies.json" ]; then
    log "INFO" "Copying policies.json from ${CONFIG_DIR}/policies/ to $POLICY_DIR/"
    cp "${CONFIG_DIR}/policies/policies.json" "$POLICY_DIR/"
  elif [ -f "${CONFIG_DIR}/policy/policies.json" ]; then
    log "INFO" "Copying policies.json from ${CONFIG_DIR}/policy/ to $POLICY_DIR/"
    cp "${CONFIG_DIR}/policy/policies.json" "$POLICY_DIR/"
  else
    log "WARNING" "policies.json not found in any standard location, will rely on default policies"
  fi
fi

# Dynamic config generation
log "INFO" "Generating dynamic policy configuration at $GENERATED_CONFIG_PATH"

# Start building the JSON configuration
cat > "$GENERATED_CONFIG_PATH" << EOF
{
  "policy_id": "${SERVICE_ID}",
  "host": "${HOST:-"0.0.0.0"}",
  "port": ${POLICY_PORT:-5000},
  "metrics_port": ${METRICS_PORT:-9091},
  "log_level": "${LOG_LEVEL:-"INFO"}",
  "log_file": "${LOG_FILE:-"/app/logs/policy-engine.log"}",
  "policy_file": "${POLICY_DIR}/policies.json"
}
EOF

# Add policy IP to configuration
if [ -n "$CLEAN_IP" ]; then
  # Use jq if available to properly update the JSON
  if command -v jq >/dev/null 2>&1; then
    jq --arg ip "$CLEAN_IP" '. + {"policy_ip": $ip}' "$GENERATED_CONFIG_PATH" > "${GENERATED_CONFIG_PATH}.tmp" && mv "${GENERATED_CONFIG_PATH}.tmp" "$GENERATED_CONFIG_PATH"
  else
    # Fallback method without jq - less safe but functional
    # Remove the last closing brace, add the new field, and add the closing brace back
    sed -i '$ s/}$/,\n  "policy_ip": "'"$CLEAN_IP"'"\n}/' "$GENERATED_CONFIG_PATH"
  fi
elif [ -n "$POLICY_IP" ]; then
  # Use policy IP if clean IP is not available
  if command -v jq >/dev/null 2>&1; then
    jq --arg ip "$POLICY_IP" '. + {"policy_ip": $ip}' "$GENERATED_CONFIG_PATH" > "${GENERATED_CONFIG_PATH}.tmp" && mv "${GENERATED_CONFIG_PATH}.tmp" "$GENERATED_CONFIG_PATH"
  else
    sed -i '$ s/}$/,\n  "policy_ip": "'"$POLICY_IP"'"\n}/' "$GENERATED_CONFIG_PATH"
  fi
fi

# Add known hostnames from environment variables
if [ -n "$FL_SERVER_HOST" ]; then
  log "INFO" "Adding fl_server_host: $FL_SERVER_HOST to config"
  if command -v jq >/dev/null 2>&1; then
    jq --arg k "fl_server_host" --arg v "$FL_SERVER_HOST" '. + {($k): $v}' "$GENERATED_CONFIG_PATH" > "${GENERATED_CONFIG_PATH}.tmp" && mv "${GENERATED_CONFIG_PATH}.tmp" "$GENERATED_CONFIG_PATH"
  else
    sed -i '$ s/}$/,\n  "fl_server_host": "'"$FL_SERVER_HOST"'"\n}/' "$GENERATED_CONFIG_PATH"
  fi
fi

if [ -n "$COLLECTOR_HOST" ] || [ -n "$NODE_IP_COLLECTOR" ]; then
  COLLECTOR_HOSTNAME=${COLLECTOR_HOST:-"metrics-collector"}
  log "INFO" "Adding collector_host: $COLLECTOR_HOSTNAME to config"
  if command -v jq >/dev/null 2>&1; then
    jq --arg k "collector_host" --arg v "$COLLECTOR_HOSTNAME" '. + {($k): $v}' "$GENERATED_CONFIG_PATH" > "${GENERATED_CONFIG_PATH}.tmp" && mv "${GENERATED_CONFIG_PATH}.tmp" "$GENERATED_CONFIG_PATH"
  else
    sed -i '$ s/}$/,\n  "collector_host": "'"$COLLECTOR_HOSTNAME"'"\n}/' "$GENERATED_CONFIG_PATH"
  fi
fi

if [ -n "$SDN_CONTROLLER_HOST" ]; then
  log "INFO" "Adding sdn_controller_host: $SDN_CONTROLLER_HOST to config"
  if command -v jq >/dev/null 2>&1; then
    jq --arg k "sdn_controller_host" --arg v "$SDN_CONTROLLER_HOST" '. + {($k): $v}' "$GENERATED_CONFIG_PATH" > "${GENERATED_CONFIG_PATH}.tmp" && mv "${GENERATED_CONFIG_PATH}.tmp" "$GENERATED_CONFIG_PATH"
  else
    sed -i '$ s/}$/,\n  "sdn_controller_host": "'"$SDN_CONTROLLER_HOST"'"\n}/' "$GENERATED_CONFIG_PATH"
  fi
fi

# Also add ports if they are defined in environment variables
if [ -n "$FL_SERVER_PORT" ]; then
  log "INFO" "Adding fl_server_port: $FL_SERVER_PORT to config"
  if command -v jq >/dev/null 2>&1; then
    jq --arg port "$FL_SERVER_PORT" '. + {"fl_server_port": ($port|tonumber)}' "$GENERATED_CONFIG_PATH" > "${GENERATED_CONFIG_PATH}.tmp" && mv "${GENERATED_CONFIG_PATH}.tmp" "$GENERATED_CONFIG_PATH"
  else
    sed -i '$ s/}$/,\n  "fl_server_port": '"$FL_SERVER_PORT"'\n}/' "$GENERATED_CONFIG_PATH"
  fi
fi

if [ -n "$COLLECTOR_PORT" ]; then
  log "INFO" "Adding collector_port: $COLLECTOR_PORT to config"
  if command -v jq >/dev/null 2>&1; then
    jq --arg port "$COLLECTOR_PORT" '. + {"collector_port": ($port|tonumber)}' "$GENERATED_CONFIG_PATH" > "${GENERATED_CONFIG_PATH}.tmp" && mv "${GENERATED_CONFIG_PATH}.tmp" "$GENERATED_CONFIG_PATH"
  else
    sed -i '$ s/}$/,\n  "collector_port": '"$COLLECTOR_PORT"'\n}/' "$GENERATED_CONFIG_PATH"
  fi
fi

if [ -n "$SDN_CONTROLLER_PORT" ]; then
  log "INFO" "Adding sdn_controller_port: $SDN_CONTROLLER_PORT to config"
  if command -v jq >/dev/null 2>&1; then
    jq --arg port "$SDN_CONTROLLER_PORT" '. + {"sdn_controller_port": ($port|tonumber)}' "$GENERATED_CONFIG_PATH" > "${GENERATED_CONFIG_PATH}.tmp" && mv "${GENERATED_CONFIG_PATH}.tmp" "$GENERATED_CONFIG_PATH"
  else
    sed -i '$ s/}$/,\n  "sdn_controller_port": '"$SDN_CONTROLLER_PORT"'\n}/' "$GENERATED_CONFIG_PATH"
  fi
fi

# Add node IPs to config - keeping this for backward compatibility, but hostnames above should be preferred
if command -v jq >/dev/null 2>&1; then
  NODE_IPS_JSON="{}"
  
  # Add all NODE_IP_ variables to the node_ips JSON object
  for var in $(env | grep "^NODE_IP_" | sort); do
    varname=$(echo "$var" | cut -d= -f1)
    ip_value=$(echo "$var" | cut -d= -f2)
    
    # Skip if invalid IP
    if ! validate_ip "$ip_value"; then
      continue
    fi
    
    # Extract component name from variable name (without NODE_IP_ prefix)
    component=$(echo "${varname#NODE_IP_}" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
    
    # Add to node_ips JSON object
    NODE_IPS_JSON=$(echo "$NODE_IPS_JSON" | jq --arg k "$component" --arg v "$ip_value" '. + {($k): $v}')
  done
  
  # Add node_ips object to config
  echo "$NODE_IPS_JSON" > "${GENERATED_CONFIG_PATH}.node_ips.json"
  jq -s '.[0] + {"node_ips": .[1]}' "$GENERATED_CONFIG_PATH" "${GENERATED_CONFIG_PATH}.node_ips.json" > "${GENERATED_CONFIG_PATH}.tmp" && mv "${GENERATED_CONFIG_PATH}.tmp" "$GENERATED_CONFIG_PATH"
  rm -f "${GENERATED_CONFIG_PATH}.node_ips.json"
else
  # Simple fallback if jq is not available - just add each NODE_IP_ as a separate entry
  for var in $(env | grep "^NODE_IP_" | sort); do
    varname=$(echo "$var" | cut -d= -f1)
    ip_value=$(echo "$var" | cut -d= -f2)
    
    # Skip if invalid IP
    if ! validate_ip "$ip_value"; then
      continue
    fi
    
    # Extract component name from variable name
    component=$(echo "${varname#NODE_IP_}" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
    key="node_ip_$(echo "$component" | tr '-' '_')"
    
    # Add to config
    sed -i '$ s/}$/,\n  "'"$key"'": "'"$ip_value"'"\n}/' "$GENERATED_CONFIG_PATH"
  done
fi

# Add any custom configuration environments with POLICY_CONFIG_ prefix
for var in $(env | grep "^POLICY_CONFIG_"); do
  key=$(echo "$var" | cut -d= -f1 | sed 's/^POLICY_CONFIG_//' | tr '[:upper:]' '[:lower:]')
  value=$(echo "$var" | cut -d= -f2)
  
  # Try to determine if value is numeric, boolean, or string
  if [[ "$value" =~ ^[0-9]+$ ]]; then
    # Integer value - no quotes
    if command -v jq >/dev/null 2>&1; then
      jq --arg k "$key" --arg v "$value" '. + {($k): ($v|tonumber)}' "$GENERATED_CONFIG_PATH" > "${GENERATED_CONFIG_PATH}.tmp" && mv "${GENERATED_CONFIG_PATH}.tmp" "$GENERATED_CONFIG_PATH"
    else
      sed -i '$ s/}$/,\n  "'"$key"'": '"$value"'\n}/' "$GENERATED_CONFIG_PATH"
    fi
  elif [[ "$value" =~ ^(true|false)$ ]]; then
    # Boolean value - no quotes
    if command -v jq >/dev/null 2>&1; then
      jq --arg k "$key" --arg v "$value" '. + {($k): ($v=="true")}' "$GENERATED_CONFIG_PATH" > "${GENERATED_CONFIG_PATH}.tmp" && mv "${GENERATED_CONFIG_PATH}.tmp" "$GENERATED_CONFIG_PATH"
    else
      sed -i '$ s/}$/,\n  "'"$key"'": '"$value"'\n}/' "$GENERATED_CONFIG_PATH"
    fi
  else
    # String value - add quotes
    if command -v jq >/dev/null 2>&1; then
      jq --arg k "$key" --arg v "$value" '. + {($k): $v}' "$GENERATED_CONFIG_PATH" > "${GENERATED_CONFIG_PATH}.tmp" && mv "${GENERATED_CONFIG_PATH}.tmp" "$GENERATED_CONFIG_PATH"
    else
      sed -i '$ s/}$/,\n  "'"$key"'": "'"$value"'"\n}/' "$GENERATED_CONFIG_PATH"
    fi
  fi
done

# Log the generated config
log "INFO" "Generated policy configuration:"
if command -v jq >/dev/null 2>&1; then
  jq . "$GENERATED_CONFIG_PATH" | tee -a "$LOG_FILE"
else
  cat "$GENERATED_CONFIG_PATH" | tee -a "$LOG_FILE"
fi

# Ensure default policies exist
ensure_default_policies "$POLICY_DIR"

# List the contents of policy directory to verify files
log "INFO" "Contents of policy directory ($POLICY_DIR):"
ls -la "$POLICY_DIR" || log "WARNING" "Could not list policy directory contents"

# Verify policy files exist
if [ ! -f "$POLICY_DIR/policies.json" ]; then
  log "WARNING" "Policy file not found at $POLICY_DIR/policies.json"
  
  # Check if we need to copy from templates
  if [ -f "$POLICY_DIR/default_policies.json" ]; then
    log "INFO" "Using default_policies.json as policies.json"
    cp "$POLICY_DIR/default_policies.json" "$POLICY_DIR/policies.json"
  else
    log "WARNING" "No default policies found to copy. Will rely on entrypoint to create basic policies."
  fi
else
  log "INFO" "Policy file found at $POLICY_DIR/policies.json"
fi

# Identify policy engine entry point
if [ -f "/app/src/policy_engine/service.py" ]; then
  POLICY_ENTRYPOINT="src.policy_engine.service"
  EXEC_MODE="module"
elif [ -f "/app/src/policy_engine/main.py" ]; then
  POLICY_ENTRYPOINT="src.policy_engine.main"
  EXEC_MODE="module"
elif [ -f "/app/main.py" ]; then
  POLICY_ENTRYPOINT="/app/main.py"
  POLICY_ARGS="--policy"
  EXEC_MODE="script"
else
  log "ERROR" "Policy Engine entry point not found. Checked: /app/src/policy_engine/service.py, /app/src/policy_engine/main.py, /app/main.py"
  exit 1
fi

# Start policy engine with appropriate arguments
log "INFO" "Starting Policy Engine using $POLICY_ENTRYPOINT (mode: $EXEC_MODE) with config $GENERATED_CONFIG_PATH"
cd /app

# Prepare command arguments
POLICY_JSON_PATH=${POLICY_FILE:-"$POLICY_DIR/policies.json"}
CMD_ARGS="--config \"$GENERATED_CONFIG_PATH\" --policy-file \"$POLICY_JSON_PATH\""

# Add additional arguments if provided
if [ -n "$POLICY_ARGS" ]; then
  CMD_ARGS="$POLICY_ARGS $CMD_ARGS"
fi

# Start in the background so we can verify it's running
if [ "$EXEC_MODE" = "module" ]; then
  # Run as a module using the -m flag to support relative imports
  log "INFO" "Executing as Python module: $POLICY_ENTRYPOINT"
  eval "python -u -m $POLICY_ENTRYPOINT $CMD_ARGS" &
else
  # Run as a script (likely main.py with --policy flag)
  log "INFO" "Executing as Python script: $POLICY_ENTRYPOINT"
  eval "python -u $POLICY_ENTRYPOINT $CMD_ARGS" &
fi

POLICY_PID=$!
log "INFO" "Policy engine started with PID: $POLICY_PID"

# Verify the policy engine API is running
verify_policy_engine_api "$POLICY_PORT"
API_RUNNING=$?

if [ $API_RUNNING -eq 0 ]; then
  log "SUCCESS" "Policy engine API is running and responding"
else
  log "WARNING" "Policy engine API may not be fully functional"
  
  # Log diagnostic information
  log "INFO" "Diagnostic information:"
  log "INFO" "Process status:"
  ps -p $POLICY_PID -f || log "WARNING" "Process not found"
  
  log "INFO" "Network ports:"
  netstat -tuln | grep LISTEN || log "WARNING" "No listening ports found"
  
  log "INFO" "Last 20 lines of log file:"
  tail -n 20 "$LOG_FILE" || log "WARNING" "Cannot display log file"
fi

# Keep the container running by waiting for the policy engine process
wait $POLICY_PID || {
  log "ERROR" "Policy engine process exited unexpectedly with status $?"
  exit 1
} 