#!/bin/bash
# Streamlined entrypoint script for OpenVSwitch container

# === BASIC SETUP ===
set -e
trap 'echo "Error on line $LINENO"; exit 1' ERR

# Setup logging
LOGS_DIR="/app/logs"
mkdir -p "$LOGS_DIR"
LOG_FILE="$LOGS_DIR/openvswitch.log"
touch $LOG_FILE
chmod 777 "$LOG_FILE"
chmod -R 777 /app/logs

set +e

# === CONFIGURATION ===
MAIN_BRIDGE="br0"
DEFAULT_OF_VERSION="OpenFlow13"
DEFAULT_CONTROLLER_PORT=6633
RECONNECT_INTERVAL=30  # Seconds between reconnection attempts
INACTIVITY_PROBE=15000 # Milliseconds (15s) for inactivity probe

# === UTILITY FUNCTIONS ===

# Log function
log() {
  local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
  local level=${1:-INFO}
  local message=$2
  if [ "$#" -eq 1 ]; then
    message=$level
    level="INFO"
  fi
  echo "[$timestamp] [OVS] [$level] $message" | tee -a "$LOG_FILE"
}

# Function to validate IP addresses
validate_ip() {
  local ip=$1
  if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    IFS='.' read -r -a segments <<< "$ip"
    for segment in "${segments[@]}"; do
      if (( segment > 255 )); then
        return 1
      fi
    done
    return 0
  else
    return 1
  fi
}

# Function to update hosts file with proper error handling
update_hosts_entry() {
  local ip=$1
  local hostname=$2
  
  # Skip if IP is invalid
  if ! validate_ip "$ip"; then
    log "WARNING" "Invalid IP for hosts entry: $ip, skipping"
    return 1
  fi
  
  # Create temp file for hosts updates
  TEMP_HOSTS=$(mktemp)
  if [ -z "$TEMP_HOSTS" ] || [ ! -f "$TEMP_HOSTS" ]; then
    log "ERROR" "Failed to create temporary file for hosts update."
    return 1
  fi
  
  # Check if entry already exists with exact match
  if grep -q "^$ip[[:space:]].*$hostname\($\|[[:space:]]\)" /etc/hosts; then
    log "DEBUG" "Hosts entry already exists for $hostname -> $ip"
    rm -f "$TEMP_HOSTS"
    return 0
  fi
  
  # Remove any existing entries for this hostname
  grep -v "[[:space:]]$hostname\($\|[[:space:]]\)" /etc/hosts > "$TEMP_HOSTS"
  echo "$ip $hostname" >> "$TEMP_HOSTS"
  cp "$TEMP_HOSTS" /etc/hosts
  rm -f "$TEMP_HOSTS"
  
  log "INFO" "Added/updated hosts entry: $ip -> $hostname"
  return 0
}

# === ENVIRONMENT DETECTION ===
detect_environment() {
  # Is this running in WSL?
  if grep -q microsoft /proc/version 2>/dev/null; then
    log "INFO" "Detected WSL2 environment"
    IS_WSL2=true
  else
    IS_WSL2=false
  fi

  # Determine if running in GNS3
  if [ "$NETWORK_MODE" = "gns3" ] || [ "$GNS3_NETWORK" = "true" ] || env | grep -q "GNS3"; then
    log "INFO" "Detected GNS3 environment"
    IS_GNS3=true
  else
    log "INFO" "Detected local/compose environment"
    IS_GNS3=false
  fi

  export IS_WSL2 IS_GNS3
}

# === NETWORK SETUP ===

# Build IP map from environment variables
build_ip_map() {
  log "INFO" "Building IP map from environment variables"
  IP_MAP=""
  for var in $(env | grep "^NODE_IP_" | sort); do
    varname=$(echo "$var" | cut -d= -f1)
    ip_value=$(echo "$var" | cut -d= -f2)
    
    if [ -z "$ip_value" ] || ! validate_ip "$ip_value"; then
      log "WARNING" "Invalid IP in $varname: $ip_value, skipping"
      continue
    fi
    
    component=$(echo "$varname" | sed "s/^NODE_IP_//" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
    
    if [ -n "$component" ]; then
      if [ -n "$IP_MAP" ]; then
        IP_MAP="${IP_MAP},${component}:${ip_value}"
      else
        IP_MAP="${component}:${ip_value}"
      fi
      log "INFO" "Added $component:$ip_value to IP map from $varname"
    fi
  done

  if [ -n "$IP_MAP" ]; then
    log "SUCCESS" "IP map is available: $IP_MAP"
  else
    log "ERROR" "No IP map available - required for OVS to operate"
    exit 1
  fi
}

# Configure static IP if required
configure_static_ip() {
  if [ "$USE_STATIC_IP" != "true" ]; then
    return 0
  fi

  log "INFO" "Static IP mode enabled, configuring network..."
  
  # Use eth0 by default
  TARGET_IFACE="eth0"
  log "INFO" "Using $TARGET_IFACE as default interface for static IP assignment"
  
  # Configure interface
  ip link set "$TARGET_IFACE" up
  ip addr flush dev "$TARGET_IFACE" scope global || true
  sleep 1
  
  # Assign static IP
  log "INFO" "Assigning static IP $OVS_IP/24 to $TARGET_IFACE"
  if ip addr add "$OVS_IP/24" dev "$TARGET_IFACE"; then
    log "SUCCESS" "IP $OVS_IP successfully assigned to $TARGET_IFACE"
    
    # Set up routing
    IFS='.' read -r -a IP_PARTS <<< "$OVS_IP"
    SUBNET="${IP_PARTS[0]}.${IP_PARTS[1]}.${IP_PARTS[2]}"
    log "INFO" "Network subnet: $SUBNET.0/24"
    
    # Add default route if needed
    if ! ip route | grep -q "default"; then
      log "INFO" "Setting up default route via $SUBNET.1"
      ip route add default via $SUBNET.1 dev eth0 || log "WARNING" "Failed to add default route"
    fi
    
    # Add explicit route to controller with better metrics
    log "INFO" "Adding direct route to SDN controller ($NODE_IP_SDN_CONTROLLER)"
    ip route add $NODE_IP_SDN_CONTROLLER/32 dev eth0 metric 10 || log "WARNING" "Failed to add direct route to controller"

    # Verify controller connectivity
    if ping -c 1 -W 2 $NODE_IP_SDN_CONTROLLER >/dev/null 2>&1; then
      log "SUCCESS" "SDN controller at $NODE_IP_SDN_CONTROLLER is reachable"
    else 
      log "WARNING" "Cannot ping SDN controller ($NODE_IP_SDN_CONTROLLER)"
    fi
  else
    log "ERROR" "Failed to assign IP $OVS_IP to $TARGET_IFACE"
  fi
}

# Update hosts file with node information
update_hosts_file() {
  log "INFO" "Adding hosts entries from NODE_IP_ variables"
  for var in $(env | grep "^NODE_IP_" | sort); do
    varname=$(echo "$var" | cut -d= -f1)
    ip_value=$(echo "$var" | cut -d= -f2)
    
    hostname=$(echo "${varname#NODE_IP_}" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
    
    log "INFO" "Adding hosts entry: $hostname -> $ip_value"
    update_hosts_entry "$ip_value" "$hostname"
  done

  # Update own IP in hosts file
  update_hosts_entry "127.0.0.1" "localhost"
  update_hosts_entry "$OVS_IP" "$HOSTNAME"
  update_hosts_entry "$OVS_IP" "openvswitch"
  update_hosts_entry "$OVS_IP" "ovs"
}

# === OVS MANAGEMENT ===

# Start OVS services (ovsdb-server and ovs-vswitchd)
start_ovs_services() {
  log "INFO" "Starting OpenVSwitch services"
  
  # Ensure required devices exist
  if [ ! -d /dev/net ]; then
    mkdir -p /dev/net
  fi
  if [ ! -c /dev/net/tun ]; then
    mknod /dev/net/tun c 10 200
  fi
  
  # Stop any existing OVS processes
  /usr/share/openvswitch/scripts/ovs-ctl stop || true
  sleep 2
  
  # Start ovsdb-server first
  log "INFO" "Starting ovsdb-server..."
  /usr/share/openvswitch/scripts/ovs-ctl start --system-id=random --no-ovs-vswitchd
  
  # Verify ovsdb-server started
  if ! pidof ovsdb-server >/dev/null; then
    log "ERROR" "ovsdb-server failed to start!"
    exit 1
  fi
  log "SUCCESS" "ovsdb-server started successfully."
  
  # Wait for OVSDB to become responsive
  log "INFO" "Waiting for OVSDB server to become responsive..."
  max_attempts=10
  attempt=1
  while ! ovs-vsctl show > /dev/null 2>&1; do
    if [ $attempt -ge $max_attempts ]; then
      log "ERROR" "OVSDB server not responsive after $max_attempts attempts."
      exit 1
    fi
    log "INFO" "OVSDB not ready, waiting... ($attempt/$max_attempts)"
    sleep 1
    ((attempt++))
  done
  log "SUCCESS" "OVSDB server is responsive."
  
  # Configure datapath type
  log "INFO" "Configuring OVS to use userspace datapath (netdev)"
  ovs-vsctl --no-wait set Open_vSwitch . other_config:datapath-type=netdev || true
  
  # Start ovs-vswitchd
  log "INFO" "Starting ovs-vswitchd..."
  
  # Choose the best approach for starting ovs-vswitchd
  if [ "$IS_WSL2" = "true" ]; then
    # WSL2-specific approach for maximum compatibility
    log "INFO" "Using WSL2-specific approach for starting ovs-vswitchd"
    
    # Locate ovs-vswitchd binary
    OVS_VSWITCHD_PATH=$(which ovs-vswitchd 2>/dev/null || echo "/usr/sbin/ovs-vswitchd")
    if [ ! -x "$OVS_VSWITCHD_PATH" ]; then
      log "ERROR" "Cannot find executable ovs-vswitchd. Searched at $OVS_VSWITCHD_PATH"
      exit 1
    fi
    
    # Ensure pidfile directory exists
    mkdir -p /var/run/openvswitch
    
    # Start with userspace options for WSL
    $OVS_VSWITCHD_PATH --pidfile --detach \
      --log-file=/var/log/openvswitch/ovs-vswitchd.log \
      --disable-system \
      -vconsole:err -vsyslog:err -vfile:info \
      --enable-dummy=override \
      --no-chdir
  else
    # Standard approach for non-WSL environments
    /usr/share/openvswitch/scripts/ovs-ctl start --no-ovsdb-server
  fi
  
  # Verify ovs-vswitchd started
  sleep 2
  if ! pidof ovs-vswitchd >/dev/null; then
    log "ERROR" "ovs-vswitchd failed to start!"
    exit 1
  fi
  log "SUCCESS" "ovs-vswitchd started successfully."
}

# Find the SDN controller URL
find_controller_url() {
  # Set controller port based on environment variables or defaults
  CONTROLLER_PORT=${SDN_CONTROLLER_PORT:-$DEFAULT_CONTROLLER_PORT}
  log "INFO" "Using controller port: $CONTROLLER_PORT"
  
  # First try to get controller IP from specific environment variable
  if [ -n "$NODE_IP_SDN_CONTROLLER" ]; then
    CONTROLLER_URL="tcp:$NODE_IP_SDN_CONTROLLER:$CONTROLLER_PORT"
    log "INFO" "Using controller from NODE_IP_SDN_CONTROLLER: $CONTROLLER_URL"
    
    # Test connectivity
    log "INFO" "Testing controller connection to $NODE_IP_SDN_CONTROLLER:$CONTROLLER_PORT"
    if timeout 2 bash -c "cat < /dev/null > /dev/tcp/$NODE_IP_SDN_CONTROLLER/$CONTROLLER_PORT" 2>/dev/null; then
      log "SUCCESS" "Controller port is open at $NODE_IP_SDN_CONTROLLER:$CONTROLLER_PORT"
      # Make sure we have an entry in hosts file
      update_hosts_entry "$NODE_IP_SDN_CONTROLLER" "sdn-controller"
      return 0
    else
      log "WARNING" "Controller port at $NODE_IP_SDN_CONTROLLER:$CONTROLLER_PORT is not responding"
    fi
  fi
  
  # Fallback: Try to find controller in IP_MAP if direct connection failed
  if [ -n "$IP_MAP" ]; then
    IFS=',' read -ra MAPPINGS <<< "$IP_MAP"
    for mapping in "${MAPPINGS[@]}"; do
      component=$(echo "$mapping" | cut -d':' -f1 | tr '[:upper:]' '[:lower:]')
      ip=$(echo "$mapping" | cut -d':' -f2)
      
      if [[ "$component" == "sdn-controller" || "$component" == "controller" ]]; then
        CONTROLLER_URL="tcp:$ip:$CONTROLLER_PORT"
        log "INFO" "Found controller in IP map: $ip:$CONTROLLER_PORT"
        
        # Add hosts file entry and return
        update_hosts_entry "$ip" "sdn-controller"
        return 0
      fi
    done
  fi
  
  # If we get here, no controller was found
  log "WARNING" "No SDN controller found. OVS will operate without a controller."
  CONTROLLER_URL=""
  return 1
}

# Create the main OVS bridge with proper configuration
create_bridge() {
  local bridge_name="$MAIN_BRIDGE"
  
  log "INFO" "Creating bridge $bridge_name"
  
  # Delete bridge if it exists (clean start)
  ovs-vsctl --if-exists del-br "$bridge_name" || true
  sleep 1
  
  # Create bridge with appropriate datapath type
  if [ "$IS_WSL2" = "true" ]; then
    log "INFO" "Creating bridge with netdev datapath for WSL2"
    ovs-vsctl --no-wait set Open_vSwitch . other_config:datapath-type=netdev
    if ! ovs-vsctl add-br "$bridge_name" -- set bridge "$bridge_name" datapath_type=netdev; then
      log "ERROR" "Failed to create bridge with netdev datapath"
      return 1
    fi
  else
    if ! ovs-vsctl add-br "$bridge_name"; then
      log "ERROR" "Failed to create bridge"
      return 1
    fi
  fi
  
  # Set OpenFlow protocol version
  if ! ovs-vsctl set bridge "$bridge_name" protocols="$DEFAULT_OF_VERSION"; then
    log "WARNING" "Failed to set OpenFlow protocol version"
  fi
  
  # ** CRITICAL FIX: Enable in-band control for bridge **
  log "INFO" "Enabling in-band control for SDN controller communication"
  ovs-vsctl set bridge "$bridge_name" other-config:disable-in-band=false
  
  # Set initial fail mode to secure
  ovs-vsctl set-fail-mode "$bridge_name" secure
  
  log "SUCCESS" "Bridge $bridge_name created successfully"
  return 0
}

# Add interfaces to bridge and handle IP address management 
add_interfaces_to_bridge() {
  local bridge="$MAIN_BRIDGE"
  local mgmt_interface="eth0"
  local interfaces_added=0
  
  log "INFO" "Adding interfaces to bridge $bridge"
  
  # Check if management interface exists before proceeding
  if [ ! -d "/sys/class/net/$mgmt_interface" ]; then
    log "WARNING" "Management interface $mgmt_interface not found in system"
    return 1
  fi
  
  # Extract current IP address from management interface before adding to bridge
  # This is crucial to maintain connectivity
  MGMT_IP=$(ip -4 addr show dev $mgmt_interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -n 1)
  MGMT_PREFIX=$(ip -4 addr show dev $mgmt_interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}/\d+' | cut -d/ -f2 | head -n 1)
  
  if [ -n "$MGMT_IP" ] && [ -n "$MGMT_PREFIX" ]; then
    log "INFO" "Saving IP $MGMT_IP/$MGMT_PREFIX from $mgmt_interface before adding to bridge"
  else
    log "WARNING" "Could not find IP address on $mgmt_interface"
  fi
  
  # Bring up the interface and add it to the bridge
  ip link set "$mgmt_interface" up || log "WARNING" "Failed to bring up $mgmt_interface"
  
  if ovs-vsctl add-port "$bridge" "$mgmt_interface"; then
    log "SUCCESS" "Added management interface $mgmt_interface to bridge $bridge"
    interfaces_added=$((interfaces_added+1))
    
    # Create internal port with the saved IP to maintain connectivity
    if [ -n "$MGMT_IP" ] && [ -n "$MGMT_PREFIX" ]; then
      log "INFO" "Creating internal port to preserve connectivity for $MGMT_IP/$MGMT_PREFIX"
      ovs-vsctl add-port "$bridge" "mgmt0" -- set interface "mgmt0" type=internal
      ip link set dev mgmt0 up
      ip addr add "$MGMT_IP/$MGMT_PREFIX" dev mgmt0
      log "SUCCESS" "Created mgmt0 interface with IP $MGMT_IP/$MGMT_PREFIX"
      
      # Create a specific route to the controller to ensure connectivity
      if [ -n "$NODE_IP_SDN_CONTROLLER" ]; then
        ip route add "$NODE_IP_SDN_CONTROLLER/32" dev mgmt0
        log "INFO" "Added direct route to SDN controller ($NODE_IP_SDN_CONTROLLER) via mgmt0"
      fi
    fi
  else
    log "ERROR" "Failed to add $mgmt_interface to bridge $bridge"
    return 1
  fi
  
  log "INFO" "Added $interfaces_added interface(s) to bridge $bridge"
  return 0
}

# Configure controller connection and settings
setup_controller() {
  local bridge="$MAIN_BRIDGE"
  
  if [ -z "$CONTROLLER_URL" ]; then
    log "WARNING" "No controller URL defined, configuring bridge for standalone operation"
    ovs-vsctl set-fail-mode "$bridge" standalone
    return 1
  fi
  
  log "INFO" "Setting controller for $bridge to $CONTROLLER_URL"
  ovs-vsctl set-controller "$bridge" "$CONTROLLER_URL"
  
  # Add essential flows for controller connectivity
  log "INFO" "Adding essential flows for controller connectivity"
  
  # Extract controller IP from the URL (tcp:IP:PORT)
  CONTROLLER_IP=$(echo "$CONTROLLER_URL" | awk -F'[:/]' '{print $2}')
  
  if [ -n "$CONTROLLER_IP" ]; then
    # Allow existing flows to remain even if controller connection drops
    ovs-vsctl set bridge "$bridge" other-config:enable-flow-aging=false
    
    # Add high-priority flow rules to ensure controller traffic priority
    ovs-ofctl -O $DEFAULT_OF_VERSION add-flow "$bridge" "table=0,priority=65000,ip,nw_dst=$CONTROLLER_IP,actions=NORMAL"
    ovs-ofctl -O $DEFAULT_OF_VERSION add-flow "$bridge" "table=0,priority=65000,ip,nw_src=$CONTROLLER_IP,actions=NORMAL"
    ovs-ofctl -O $DEFAULT_OF_VERSION add-flow "$bridge" "table=0,priority=65000,arp,nw_dst=$CONTROLLER_IP,actions=NORMAL"
    ovs-ofctl -O $DEFAULT_OF_VERSION add-flow "$bridge" "table=0,priority=65000,arp,nw_src=$CONTROLLER_IP,actions=NORMAL"
    
    # Add flow rules for OpenFlow protocol and controller port
    ovs-ofctl -O $DEFAULT_OF_VERSION add-flow "$bridge" "table=0,priority=65000,tcp,tp_dst=6633,actions=NORMAL"
    ovs-ofctl -O $DEFAULT_OF_VERSION add-flow "$bridge" "table=0,priority=65000,tcp,tp_src=6633,actions=NORMAL"
    
    # Add backup rules for potential alternate OpenFlow port
    ovs-ofctl -O $DEFAULT_OF_VERSION add-flow "$bridge" "table=0,priority=65000,tcp,tp_dst=6653,actions=NORMAL"
    ovs-ofctl -O $DEFAULT_OF_VERSION add-flow "$bridge" "table=0,priority=65000,tcp,tp_src=6653,actions=NORMAL"
    
    # Add default flow rules for basic connectivity
    ovs-ofctl -O $DEFAULT_OF_VERSION add-flow "$bridge" "table=0,priority=100,in_port=LOCAL,actions=NORMAL"
    ovs-ofctl -O $DEFAULT_OF_VERSION add-flow "$bridge" "table=0,priority=0,actions=CONTROLLER:65535"
    
    log "INFO" "Added priority flow rules for controller traffic"
  fi
  
  # Configure controller connection parameters
  log "INFO" "Setting controller connection parameters"
  # Get controller UUID (will be needed for setting parameters)
  CONTROLLER_ID=$(ovs-vsctl --column=_uuid list Controller | grep -o "^[0-9a-f-]*")
  
  if [ -n "$CONTROLLER_ID" ]; then
    log "INFO" "Setting connection parameters for controller: ${CONTROLLER_ID}"
    # Set connection mode to in-band - essential for connectivity through the bridge itself
    ovs-vsctl set controller ${CONTROLLER_ID} connection_mode=in-band
    
    # Increase max_backoff to prevent aggressive reconnection but keep inactivity_probe
    # reasonably short for quick discovery of connection issues
    ovs-vsctl set controller ${CONTROLLER_ID} max_backoff=5000
    ovs-vsctl set controller ${CONTROLLER_ID} inactivity_probe=$INACTIVITY_PROBE
    
    # Remove any local_ip restriction that might interfere with connectivity
    ovs-vsctl remove controller ${CONTROLLER_ID} local_ip 2>/dev/null || true
  else
    log "WARNING" "No controller ID found for $bridge, skipping advanced parameters"
  fi
  
  # Verify connection after 3 seconds
  log "INFO" "Waiting for controller connection to establish..."
  sleep 3
  
  # Check connection status
  if ovs-vsctl -- get controller "$bridge" is_connected 2>/dev/null | grep true >/dev/null; then
    log "SUCCESS" "Controller connection established successfully"
    # Keep secure mode when controller is connected
    ovs-vsctl set-fail-mode "$bridge" secure
    return 0
  else
    log "WARNING" "Controller connection did not establish within timeout"
    # Try alternate port
    if [[ "$CONTROLLER_URL" == *":6633" ]]; then
      ALTERNATE_URL="${CONTROLLER_URL/:6633/:6653}"
      log "INFO" "Trying alternate controller port: $ALTERNATE_URL"
      ovs-vsctl set-controller "$bridge" "$ALTERNATE_URL"
      sleep 3
      
      if ovs-vsctl -- get controller "$bridge" is_connected 2>/dev/null | grep true >/dev/null; then
        log "SUCCESS" "Controller connected on alternate port"
        CONTROLLER_URL="$ALTERNATE_URL"
        ovs-vsctl set-fail-mode "$bridge" secure
        return 0
      fi
    fi
    
    # If still not connected, add fallback rules but keep trying to connect
    log "WARNING" "Could not connect to controller, adding fallback flow rules"
    ovs-ofctl -O $DEFAULT_OF_VERSION add-flow "$bridge" "table=0,priority=2000,ip,actions=NORMAL"
    ovs-ofctl -O $DEFAULT_OF_VERSION add-flow "$bridge" "table=0,priority=2000,arp,actions=NORMAL"
    
    # Keep in secure mode but with fallback rules
    return 1
  fi
}

# Monitor and maintain controller connection
monitor_controller_connection() {
  local bridge="$MAIN_BRIDGE"
  local interval="$RECONNECT_INTERVAL"
  
  log "INFO" "Starting controller connection monitoring (interval: ${interval}s)"
  
  # Run in background
  (
    while true; do
      # Skip if no controller was configured
      if [ -z "$CONTROLLER_URL" ]; then
        sleep "$interval"
        continue
      fi
      
      # Check connection status
      if ! ovs-vsctl -- get controller "$bridge" is_connected 2>/dev/null | grep true >/dev/null; then
        log "WARNING" "Controller connection lost, attempting to reconnect"
        
        # Reconnect procedure
        ovs-vsctl del-controller "$bridge" || true
        sleep 1
        ovs-vsctl set-controller "$bridge" "$CONTROLLER_URL"
        sleep 3
        
        # Verify if reconnection worked
        if ovs-vsctl -- get controller "$bridge" is_connected 2>/dev/null | grep true >/dev/null; then
          log "INFO" "Successfully reconnected to controller"
          
          # Update controller parameters after reconnection
          CONTROLLER_ID=$(ovs-vsctl --column=_uuid list Controller | grep -o "^[0-9a-f-]*")
          if [ -n "$CONTROLLER_ID" ]; then
            ovs-vsctl set controller ${CONTROLLER_ID} connection_mode=in-band
            ovs-vsctl set controller ${CONTROLLER_ID} max_backoff=5000
            ovs-vsctl set controller ${CONTROLLER_ID} inactivity_probe=$INACTIVITY_PROBE
          fi
        else
          log "WARNING" "Reconnection attempt failed, will retry in ${interval} seconds"
        fi
      fi
      
      sleep "$interval"
    done
  ) &
  
  # Save the PID for potential cleanup
  MONITOR_PID=$!
  log "INFO" "Controller monitor started with PID $MONITOR_PID"
}

# === MAIN EXECUTION ===

# Initialize and get environment variables
log "INFO" "Starting OpenVSwitch entrypoint script"

# Get container information and settings
HOSTNAME=${HOSTNAME:-$(hostname)}
CONTAINER_ID=$(cat /etc/hostname)
SERVICE_TYPE=${SERVICE_TYPE:-openvswitch}
SERVICE_ID=${SERVICE_ID:-ovs-1}
LOG_LEVEL=${LOG_LEVEL:-INFO}
NETWORK_MODE=${NETWORK_MODE:-docker}
GNS3_NETWORK=${GNS3_NETWORK:-false}
USE_STATIC_IP=${USE_STATIC_IP:-false}

# Get OVS ID from SERVICE_ID if it contains a number
OVS_OFFSET=0
if [[ "$SERVICE_ID" =~ [0-9]+$ ]]; then
  OVS_OFFSET=$(echo "$SERVICE_ID" | grep -oE '[0-9]+$')
fi

log "INFO" "Service type: $SERVICE_TYPE"
log "INFO" "Service ID: $SERVICE_ID"
log "INFO" "OVS ID: $OVS_OFFSET"

# Environment detection
detect_environment

# Build IP mapping and get OVS IP
build_ip_map

# Get the OVS IP 
OVS_IP_VAR="NODE_IP_OPENVSWITCH"
if [ "$OVS_OFFSET" -gt 1 ]; then
  OVS_IP_VAR="NODE_IP_OPENVSWITCH_${OVS_OFFSET}"
fi
OVS_IP=${!OVS_IP_VAR}

if [ -z "$OVS_IP" ]; then
  log "ERROR" "No IP found for $OVS_IP_VAR environment variable"
  exit 1
fi
log "INFO" "OVS IP: $OVS_IP"

# Configure network with static IP if requested
configure_static_ip

# Update hosts entries
update_hosts_file

log "INFO" "OVS environment setup complete"

# Start OpenVSwitch services
start_ovs_services

# Find controller URL
find_controller_url

# Set up the main bridge
create_bridge

# Add interfaces to bridge with IP management
add_interfaces_to_bridge

# Set up controller connection
setup_controller

# Show current flow tables
log "INFO" "Current flow tables:"
ovs-ofctl -O $DEFAULT_OF_VERSION dump-flows "$MAIN_BRIDGE" || log "WARNING" "Failed to dump flows"

# Set up persistent controller monitoring
monitor_controller_connection

# After successful setup, keep the container running
log "INFO" "OpenVSwitch setup complete. Running in foreground..."

# Handle termination signals properly
trap 'log "INFO" "Received shutdown signal, exiting cleanly..."; exit 0' SIGTERM SIGINT

# Stay in foreground with logs
tail -f /var/log/openvswitch/ovs-vswitchd.log
